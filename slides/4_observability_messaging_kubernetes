---
marp: true
theme: default
style: |
  section::before {
    content: '';
    position: absolute;
    top: 30px;
    right: 30px;
    width: 200px;
    height: 50px;
    background-image: url('assets/ascent_formation_logo.png');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: right;
  }
  section::after {
    content: '';
    position: absolute;
    top: 90px;
    right: 30px;
    width: 100px;
    height: 25px;
    background-image: url('assets/quarkus_logo.png');
    background-size: contain;
    background-repeat: no-repeat;
    background-position: right;
  }
  section.fit-table table {
    font-size: 22px;
  }
  section.fit-table th, section.fit-table td {
    padding: 4px 8px;
  }
---

# Morning Session 2 (11:00 - 12:00)
## Topic: Observing Your Microservices

---

# Why Observability?

In a complex microservices architecture, you need to answer:
- **Is the service running?** (Health Checks)
- **How is the service performing?** (Metrics)
- **What happened during a specific request?** (Distributed Tracing - covered later)

Observability is key to debugging, monitoring, and maintaining a healthy system.

---

# MicroProfile Health

Exposes health check procedures to let orchestrators (like Kubernetes) know if your application is healthy.

- **Two types of checks**:
  - **Liveness (`/q/health/live`)**: Is the application running? If this fails, the container should be restarted.
  - **Readiness (`/q/health/ready`)**: Is the application ready to accept requests? If this fails, the container should be temporarily removed from the load balancer.
- **Guide**: [MicroProfile Health](https://quarkus.io/guides/microprofile-health)

---

# Implementing Health Checks

Create a bean that implements `HealthCheck` and is annotated with `@Liveness` or `@Readiness`.

```java
@Liveness
@ApplicationScoped
public class DatabaseConnectionHealthCheck implements HealthCheck {

    @Override
    public HealthCheckResponse call() {
        if (isDatabaseConnectionOk()) {
            return HealthCheckResponse.up("Database connection is OK");
        } else {
            return HealthCheckResponse.down("Database connection is down");
        }
    }
}
```

---

# MicroProfile Metrics

Provides a standard way to instrument your application with metrics.
- **Metrics exposed at `/q/metrics`** in Prometheus format.
- **Default Metrics**: Quarkus provides many metrics out-of-the-box (CPU, memory, HTTP requests, etc.).
- **Custom Metrics**: You can add your own application-specific metrics.
- **Guide**: [MicroProfile Metrics](https://quarkus.io/guides/microprofile-metrics)

---

# Custom Metrics Annotations

- `@Counted`: How many times a method has been called.
- `@Timed`: The duration of method calls (timer).
- `@Gauge`: The current value of something (e.g., queue size).

```java
@POST
@Counted(name = "trainStopCreations", description = "How many train stops have been created.")
@Timed(name = "trainStopCreationTimer", description = "A measure of how long it takes to create a train stop.")
public Response create(TrainStop stop) {
    // ...
}
```